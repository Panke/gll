module tests.testgrammar;
import gll.grammar, gll.data, gll.gll;
/**
* A Gll example parser.
*
* Used as a template for generation and as a test case for the
* data structures.
*
* Shall recognize strings according to the following grammar.
*
* S ::= E
* S ::= E;S
* S ::= Îµ
* E ::= N
* E ::= E + E
* E ::= E - E
* E ::= E!
* N ::= 'n'
*/


/+
/* TokenKind defined in user code for the grammar above. */
enum EspGramTokenKind 
{
    Number,
    Minus,
    Plus,
    Semi,
    Bang
}


/*
 * The generated code requires the user to provide as template Parameter
 *  * The Type that's used as a token as generated by the lexer. 
 *  * A compare function. This is used to compare token values to 'TokenKinds'
 *    expected by the parser. This TokenKind is the exactly same type thats
 *    used for the Grammar. 
 *  * The TokenKind. It's in extra parameter, so its name can be freely chosen.
 *    Currently only an enum value is supported, but it may be chosen to be 
 *    any integral type in the future. (Thus making parser that act on individual
 *    characters easier to construct
 */
struct Recognizer(Token, TK, alias compare)
{
    Token[] input;
    GllContext context;
    this(Token[] _input)
    {
        input = _input;
        context = new GllContext();
    }

    // generated from grammar.
    enum Label
    {
        Loop,
        S_0E,
        S_E0,
        S_0E_Semi_S,
        S_E0_Semi_S,
        S_E_Semi_0S,
        S_E_Semi_S0,
        E_0N,
        E_N0,
        E_0E_PL_E,
        E_E0_PL_E,
        E_E_PL_0E,
        E_E_PL_E0,
        E_0E_MIN_E,
        E_E0_MIN_E,
        E_E_MIN_0E,
        E_E_MIN_E0,
        E_0E_B,
        E_E_0B,
        N_0n,
        // labels for Nonterminals
        _S,
        _E,
        _N,
    }


    bool parse()
    {
        InputPos curIdx;
        GssId curTop;
        Tags curLabel = Loop;
        with(Label) {
            
        /* setup for data structures .. ? */
        while(true)
        {
            final switch(curLabel)
            {
                case Loop:
                    if(context.pendingSet.empty)
                        return (curIdx == input.length);
                    else
                    {
                        auto desc = context.pendingSet.pop;
                        curIdx = desc.index;
                        curtop = desc.stackTop;
                        curLabel = desc.label;
                        break;
                    }
                case _S:
                    if(compare(input[curIdx], TK.Num)) // the names here come from the grammar
                    {
                        context.add(S_0E);
                        context.add(S_0E_Semi_S);
                    }
                    curLabel = Loop; break;
                case _E:
                    if(compare(input[curIdx], TK.Num))
                    {
                        context.add(E_0E_B, curIdx, curTop);
                        context.add(E_0E_MIN_E, curIdx, curTop);
                        context.add(E_0E_PL_E, curIdx, curTop);
                        context.add(E_0N, curIdx, curTop);
                    }
                    curLabel = Loop; break;
                case _N:
                    if(compare(input[curIdx], TK.Num))
                    {
                        curIdx++;
                        context.pop(curTop, curIdx );
                    }
                    curLabel = Loop; break;
                    
                case S_0E:
                    curTop = context.create(S_E0, curIdx, curTop);
                    curLabel = _E; break;
                case S_E0:
                    context.pop(curTop, curIdx);
                    curLabel = Loop; break;

                
                case E_0E_B:
                    curTop = context.create(E_E_0B, curIdx, curTop);
                    curLabel = _E; break;
                case E_E_0B:
                    if(compare(input[curIdx], TK.Bang))
                    {
                        curIdx++;
                        context.pop(curTop, curIdx);
                    }
                    curLabel = Loop; break;

                case E_0E_MIN_E:
                    curTop = context.create(E_E0_MIN_E, curIdx, curTop);
                    curLabel = _E; break;
                case E_E0_MIN_E:
                    if(compare(input[curIdx], TK.Minus))
                    {
                        curIdx++;
                        curTop = context.create(E_E_MIN_E0, curIdx, curTop);
                        curLabel = _E; break;
                    }
                    curLabel = Loop; break;
                case E_E_MIN_E0:
                    context.pop(curTop, curIdx);

                case E_0N:
                    curTop = context.create(E_N0, curIdx, curTop);
                    curLabel = _N; break;
                case E_N0:
                    context.pop(curTop; curIdx);
            }
            
            // here something is still missing.
        }
    }
}

+/
